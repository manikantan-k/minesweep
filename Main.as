package {	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.events.Event;	public class Main extends MovieClip	{		var ROWS:int = 10;		var COLUMNS:int = 10;		var LEFTMARGIN:int = 100;		var TOPMARGIN:int = 100;		var SEP:int = 1; //separation between two cells		var levels:Array = [ [4,6,13,19,31,35,39,45,58,63,68,71,89,94,99],							 [3,5,9,11,19,23,36,42,53,67,74,83,87,94],							 [5,11,16,19,25,33,38,46,50,62,68,75,84,96],							 [5,14,37,63,75,84,96]];		//These levels are random & are not setup according to difficulty level.		var mines:Array ; //mines list in the currently playing game		var cnt:Array;  //An array of ROWS*COLUMNS elements which store the number for each cell. -1 indicates a mine		var openMines:int ; //Flagged mines count				public function Main()		{			// constructor code									addEventListener(MouseEvent.RIGHT_CLICK, function(e:MouseEvent){});			reset.addEventListener(MouseEvent.CLICK, resetBoard);			resetBoard(new Event("fakeEvent")); //generate a fake event the first time. Other times, the mouse click can go in.		}		/*******************		Used to clear stuff before a new game, & chooses a random level		*******************/		public function resetBoard(e:Event) {			var gamenum:int = Math.floor(Math.random() * levels.length);			trace("choosing" + gamenum);			result.text = "";			beginLevel(gamenum);		}		/*******************		Clear data in cnt array, add the mines to cnt array, increment neighbouring cell's cnt value for each mine.		*******************/		public function beginLevel(gamenum:int)		{			//init to zero			cnt = [];			openMines = 0;						mines = levels[gamenum];			trace(mines + "" + mines.length);			gameNum.text = ""+ (gamenum +1);			opened.text = openMines + "";			total.text = mines.length + "";						for (var i=0; i<ROWS; i++)			{				cnt[i] = [];				for (var j=0; j<COLUMNS; j++)				{					cnt[i][j] = 0;				}			}			// add the mines			var val:int;			for (i=0; i< mines.length; i++)			{				val = mines[i];				//trace("Mine at" + val);				cnt[Math.floor(val/COLUMNS)][val%ROWS] = -1;				incrementNeighbours(val);			}			var c:Cell;			if(getChildByName("1c3") == null) {			//Draw cells				trace("Fresh");				for (i=0; i<ROWS; i++)				{					for (j=0; j<COLUMNS; j++)					{						c = new Cell();						c.x = LEFTMARGIN + (SEP + c.width) * j;						c.y = TOPMARGIN + (SEP + c.height) * i;						c.name = i + "c" + j; //name each cell to reference later						addChild(c);						c.addEventListener(MouseEvent.CLICK, cellClicked);						c.addEventListener(MouseEvent.RIGHT_CLICK, markCell);					}				}			}			else { //cells are already on stage, just reset them				for (i=0; i<ROWS; i++)				{					for (j=0; j<COLUMNS; j++)					{						c = getChildByName( i + "c" + j) as Cell;						c.gotoAndStop(1);						c.addEventListener(MouseEvent.CLICK, cellClicked);						c.addEventListener(MouseEvent.RIGHT_CLICK, markCell);					}				}			}		}		/*******************		If unopened cell is clicked, call openCell		*******************/		public function cellClicked(e:MouseEvent)		{			if ( (MovieClip) (e.target).currentFrame == 1)			{				var nam:String = e.target.name;				var rowIndex:int = int(nam.substring(0,nam.indexOf('c')));				var columnIndex:int = int(nam.substring(nam.indexOf('c') + 1));				trace("open" + rowIndex + "," + columnIndex);				openCell(rowIndex, columnIndex);			}		}		/*******************		If cell to open is a mine, end game & validate board		If count is zero, open neighbours		If flagged, ignore this		Else simply open & show the cnt for the cell		*******************/		public function openCell(rowIndex:int, columnIndex:int)		{	trace("open" + rowIndex + "," + columnIndex + "val" + cnt[rowIndex][columnIndex]);			var c:Cell = getChildByName(rowIndex + "c" + columnIndex) as Cell;			if (cnt[rowIndex][columnIndex] == -1)			{				trace("Mine opened");				c.gotoAndStop(3);				validate();							}			else if (cnt[rowIndex][columnIndex] == 0  && c.currentFrame ==1)			{												//open the selected cell								c.gotoAndStop(4);				c.txt.text = cnt[rowIndex][columnIndex]+"";								//open neighbours				//Start with cells above the current Mine				if (rowIndex -1 >=0 && columnIndex-1>=0 && cnt[rowIndex-1][columnIndex-1] != -1 )				{					openCell(rowIndex -1, columnIndex -1);				}				if (rowIndex -1 >=0 && cnt[rowIndex-1][columnIndex] != -1 )				{					openCell(rowIndex -1, columnIndex);				}				if (rowIndex -1 >=0 && columnIndex+1<COLUMNS && cnt[rowIndex-1][columnIndex+1] != -1 )				{					openCell(rowIndex -1, columnIndex +1);				}				//The cells below the current Mine				if (rowIndex +1 <ROWS && columnIndex-1>=0 && cnt[rowIndex+1][columnIndex-1] != -1 )				{					openCell(rowIndex +1, columnIndex -1);				}				if (rowIndex +1 <ROWS  && cnt[rowIndex+1][columnIndex] != -1 )				{					openCell(rowIndex +1, columnIndex );				}				if (rowIndex +1 <ROWS && columnIndex+1<COLUMNS && cnt[rowIndex+1][columnIndex+1] != -1 )				{					openCell(rowIndex +1, columnIndex +1);				}				//The cells to left & right				if (columnIndex-1>=0 && cnt[rowIndex][columnIndex -1] != -1 )				{					openCell(rowIndex , columnIndex -1);				}				if (columnIndex+1<COLUMNS && cnt[rowIndex][columnIndex+1] != -1 )				{					openCell(rowIndex, columnIndex +1);				}											}			else if(c.currentFrame ==2) {				//This cell has been flagged, dont disturb this			}			else			{								c.gotoAndStop(4);				c.txt.text = cnt[rowIndex][columnIndex];			}		}		/*******************		Flags a cell, increments no. of flagged mines		*******************/		public function markCell(e:MouseEvent)		{			var nam:String = e.target.name;			var rowIndex:int = int(nam.substring(0,nam.indexOf('c')));			var columnIndex:int = int(nam.substring(nam.indexOf('c') + 1));			trace("right" + rowIndex + "," + columnIndex);			var c:Cell = getChildByName(rowIndex + "c" + columnIndex) as Cell;			if(c.currentFrame == 1) {				c.gotoAndStop(2);				opened.text = ++openMines + "";			}			else if(c.currentFrame == 2) {				c.gotoAndStop(1);				opened.text = --openMines + "";			}			//user has flagged required mines			if(openMines == mines.length) {				//do the calculation math				validate();			}					}		/*******************		Check for incorrectly flagged cells, unflagged mines.		Count the number of correctly flagged cells		*******************/		public function validate() {			//disable all interactivity on board & check if flagged correctly			var correct:int =0;			for (var i:int=0; i<ROWS; i++)				{					for (var j:int=0; j<COLUMNS; j++)					{						var c:Cell = getChildByName(i+"c"+j) as Cell;						c.removeEventListener(MouseEvent.CLICK, cellClicked);						c.removeEventListener(MouseEvent.RIGHT_CLICK, markCell);						if(c.currentFrame == 2 && cnt[i][j] != -1) { 								// this cell is flagged incorrectly								c.gotoAndStop(5);						}						else if(cnt[i][j] == -1 && c.currentFrame !=2) {							//this mine was not flagged							c.gotoAndStop(3);						}						else if(cnt[i][j] == -1 && c.currentFrame ==2) {							//this cell was flagged correctly							correct++;						}					}			}			result.text = correct + " mine(s) were flagged correctly";		}		/*******************		If neighbour is not a mine, increment its cnt.		*******************/		public function incrementNeighbours(pos:int)		{			var rowIndex:int = Math.floor(pos/COLUMNS);			var columnIndex:int = pos % ROWS;			//neighbours. Check if exists & not a mine & increment count			//The cells above the current Mine			if (rowIndex -1 >=0 && columnIndex-1>=0 && cnt[rowIndex-1][columnIndex-1] != -1 )			{				cnt[rowIndex - 1][columnIndex - 1]++;			}			if (rowIndex -1 >=0 && cnt[rowIndex-1][columnIndex] != -1 )			{				cnt[rowIndex - 1][columnIndex]++;			}			if (rowIndex -1 >=0 && columnIndex+1<COLUMNS && cnt[rowIndex-1][columnIndex+1] != -1 )			{				cnt[rowIndex - 1][columnIndex + 1]++;			}			//The cells below the current Mine			if (rowIndex +1 <ROWS && columnIndex-1>=0 && cnt[rowIndex+1][columnIndex-1] != -1 )			{				cnt[rowIndex + 1][columnIndex - 1]++;			}			if (rowIndex +1 <ROWS  && cnt[rowIndex+1][columnIndex] != -1 )			{				cnt[rowIndex + 1][columnIndex]++;			}			if (rowIndex +1 <ROWS && columnIndex+1<COLUMNS && cnt[rowIndex+1][columnIndex+1] != -1 )			{				cnt[rowIndex + 1][columnIndex + 1]++;			}			//The cells to left & right			if (columnIndex-1>=0 && cnt[rowIndex][columnIndex -1] != -1 )			{				cnt[rowIndex][columnIndex - 1]++;			}			if (columnIndex+1<COLUMNS && cnt[rowIndex][columnIndex+1] != -1 )			{				cnt[rowIndex][columnIndex + 1]++;			}		}	}}